The process for constructing a visual display of a tree goes like this: construct a Grid, passing the root node of the data tree into its constructor. The Grid is actually a custom class for the sort of data it's meant to display, like a CodeGrid, rather than just a Grid. CodeGrid constructs a display cell, like a CodeCell, passing it the data node for each immediate child of the root. If a CodeCell is clicked on, it creates a new CodeGrid which repeats the process. The CodeCells remain independent, but  the data tree's nodes have references to their children. Non-visible nodes (non-leaves I suppose) are Grids, which display their just their immediate children.


I think the current Cell class should become a CellController Which contains a CellDisplay (three actually, since I'll allow three layers of them) and a data tree node. The CellController configures its CellDisplays based on the data tree node that it contains, and updates the CellDisplays based on user input (for things like glowing on mouseover).

Could use three distinct configuration file-types. Their formats are the same--basically a hashmap in text--though the keys they store are different. The three I'm thinking of right now are cell.config grid.config and app.config. There should probably only be one app.config, but for the others there can be several configuration files. This way, cell1.config could be use for setting up the appearance of CodeCells, and cell2.config could be used for menu cells.

Since grid sequences are built off of tree structures (so far, just the trees produced by an ANTLR produced parser), XML would be an ideal format for describing "Guides" (a name I'm toying with for the wizard-like grid sequences). Using XML, I can use a free xml parser and convert the tree given by the parser into a tree of the same format as the ANTLR trees; this way there is one process for building UIs, whether they be produced by a grammar and some source code or whether they are defined manually.

By having activate/deactivate methods in CellController, it should be possible to carry out the render-to-texture string caching on a separate thread before Cells appear on-screen: just activate CellControllers when they are within a distance of one screen from being visible, and deactivate them when they leave that range.

Using NIO, it should be possible to carry out edits by just re-writing the structure containing the edit. For instance if a line of code sitting inside the main method is edited, the main method would have to be re-written to the file. There probably will be a template used for writing to files; hopefully it can scale to work with any subset of the AST it is printing. As long as that's the case, structures can store their beginning and ending location in the actual source file (beginning and ending index of a method for instance), delete that portion of the file, then have the template re-print the part of the AST which corresponds to the method.

-----------

Each program will have an xml document associated with it, which contains sections for grids, which contain sections for cells. The program xml document will attach a grid configuration (a block of xml in the same file) to each grid it describes, and each grid will specify a cell configuration as well as a particular cell class to use. It's possible that a good approach for creating the cells for a grid is to construct one, passing in its configuration info, and then use a .copy() method inside of Cell to get instances for the rest.

The program class will use its configuration info to construct a heirarchy of windows, each having a grid. It will pass configuration information to each grid, which will pass config. info. to its cells. The cells will then load their resources, the the grids, then the windows. When the program ends, it will tell everyone to dispose of their resources. The resource manager will track who has requested which resources; if no one else is using a given resource, it will be released.

When a cell with children is clicked on, causing the current grid and cells to be disposed and a new grid to be constructed, the new grid can be constructed in the same manner as the first, using its load method to grab resources from the resource manager. If grids have some parameter for whether they should release resources on disposal or not, then this should not be a problem. Grids can keep their resources around when disposed, and when the program is finally disposed it can force all its grids to release their resources.