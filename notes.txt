[2015 Weston]: 

	Probably the thing that made writing TTE so difficult was a certain inelegance arising from the fact that you maintained a sort of ‘mixed tree’ that was both the parse tree and your modified/simplified tree that corresponded to TTE’s document layout. Your simplified tree, for instance, removed structure from arithmetic expressions and control structures, and it added structure for lines. A better approach would be to be explicit about the fact that there are two separate structures, and use a function that maps parts of one onto the other. When you have nodes that are removed, map them to a ‘zero’ element, and perhaps store the particular mapping of whatever set of nodes to the zero element, so that when you need to convert a particular zero element back, you can get your original nodes back. Going the other direction, where you’re adding structure, your mapping takes a bunch of nodes (comprising tokens in this case) and maps them to a single ‘line’ node; you should also be able to invert this and take the line back to tokens when necessary.
	The process should be something like: (1) load document, parse it, store parse tree. (2) run parse tree through converter function to get the ‘layout tree’ (instructions for how to form it are in a separate file; I believe I already indicate it’s construction this way: it’s the grammar ‘annotation’ aspect of TTE). (3) Use the layout tree to create the TTE GUI. (4) when someone tries removing nodes from the layout, use the mapping function to convert the layout nodes to the parse tree nodes, and remove the corresponding parse tree nodes from the parse tree; when someone tries moving nodes, convert the lifted layout nodes to parse nodes, and when they drop their selection, try incorporating the parse nodes into the parse tree to see if it’s valid, if so, convert back to layout nodes and add the layout nodes to the document; when ‘pasting’ text externally, re-parse the document in the region where the text was inserted, if it parses, convert the parse nodes to layout nodes and add them to the document.
	OR, MORE LIKELY: It also may just be that it really needed to be structured in such a way that when drawing a frame, the renderer polls the model and constructs a view on the fly, rather than trying to put everything (view-wise) in its place as events occur.

To deal with parse errors: just leave the section with the parse error ‘structureless’; in other words, it’s either a single tile for the whole region, or if you go inside, it goes immediately to the character level.

Better also for ‘incremental’ parsing: always parse from the top rule, but! when going from parse tree to text, only add the text from direct parent nodes; if it’s an uncle or something, just don’t add that text.


*********OLD NOTES***************

There's a bug when navigating at the line level (maybe word) and moving around on curly braces -- it will jump to the previous method.

-------------------------------------
There seems to be an issue with too much memory consumptions (which really may just be the GC releasing too slowly) when using the 1.7JVM (using around 300megs), whereas on 1.6 mem usage is fine (60megs). This certainly seems to be related to having too many Character arrays (i.e. Strings -- StringBuilders  more accurately I think) due to creating too many GLStrings/GLStringAtoms for displaying code.