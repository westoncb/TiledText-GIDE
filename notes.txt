[2015 Weston]: 

	Probably the thing that made writing TTE so difficult was a certain inelegance arising from the fact that you maintained a sort of ‘mixed tree’ that was both the parse tree and your modified/simplified tree that corresponded to TTE’s document layout. Your simplified tree, for instance, removed structure from arithmetic expressions and control structures, and it added structure for lines. A better approach would be to be explicit about the fact that there are two separate structures, and use a function that maps parts of one onto the other. When you have nodes that are removed, map them to a ‘zero’ element, and perhaps store the particular mapping of whatever set of nodes to the zero element, so that when you need to convert a particular zero element back, you can get your original nodes back. Going the other direction, where you’re adding structure, your mapping takes a bunch of nodes (comprising tokens in this case) and maps them to a single ‘line’ node; you should also be able to invert this and take the line back to tokens when necessary.
	The process should be something like: (1) load document, parse it, store parse tree. (2) run parse tree through converter function to get the ‘layout tree’ (instructions for how to form it are in a separate file; I believe I already indicate it’s construction this way: it’s the grammar ‘annotation’ aspect of TTE). (3) Use the layout tree to create the TTE GUI. (4) when someone tries removing nodes from the layout, use the mapping function to convert the layout nodes to the parse tree nodes, and remove the corresponding parse tree nodes from the parse tree; when someone tries moving nodes, convert the lifted layout nodes to parse nodes, and when they drop their selection, try incorporating the parse nodes into the parse tree to see if it’s valid, if so, convert back to layout nodes and add the layout nodes to the document; when ‘pasting’ text externally, re-parse the document in the region where the text was inserted, if it parses, convert the parse nodes to layout nodes and add them to the document.
	OR, MORE LIKELY: It also may just be that it really needed to be structured in such a way that when drawing a frame, the renderer polls the model and constructs a view on the fly, rather than trying to put everything (view-wise) in its place as events occur.
	I think if you do both of the above things and get rid of the idea of being at one abstraction level, and node types having abstraction levels (replacing it with specific nodes either being collapsed or expanded), this will actually be pretty straightforward to code.

As a way of going about executing this refactor: maybe start from scratch in the sense that you start writing a new Tiled Text Program, rather than trying to modify the old CodeEditor program (by ‘Program’ I mean, like, ‘Program.java’ from the framework). This way you can keep using all the mundane stuff, but not have to worry about disentangling the nasty stuff you’re going to be restructuring anyway.

Probably just leave off animations, deleting all the old EventManager etc. stuff, then do something like the PropertyModulator system that can do automatic animation when changing thing’s positions.

To deal with parse errors: just leave the section with the parse error ‘structureless’; in other words, it’s either a single tile for the whole region, or if you go inside, it goes immediately to the character level.

SYNTAX-FREE PROGRAMMING: the ‘input side’ of TTE allows for syntax free programming. It’s pretty nice with existing programming languages because you don’t have to memorize syntax: you just have to choose from options on a least (takes you from being able to read in a language to being able to write in it). However, if languages were designed in terms of a graph of ‘construct decisions’—much like you get when turning the grammar for a language into a graph—and writing programs consisted of walking this graph, deciding which edge to take from whichever node you’re at, then you could attach a ‘language view’ to the decisions instead of building everything up from a particular view choice to begin with. This allows for a refined form of decision making within a language that has users dealing in something that’s much closer to pure semantics; it also would allow a much greater freedom in constructing views for languages. And, you could get the kind of clean self-reference as in (I believe) Lisp macros, while still having a sophisticated syntax (since the syntax is just a view generated afterward. Largely this works by: whenever you specify a program structure, it is by giving a path through a graph of legal language construction decisions; specifying a new structure in terms of one already created can be done in terms of a modification to a path on a graph—no need to mess with intricacies of syntax!. An interpreter in a normal system is like:

source language -> semantic representation -> machine code

In a syntax-free system it’s like:

semantic representation -> machine code
semantic representation -> view language

MACROS: programs are stored as sequences of ‘program construct decisions,’ indicating which paths were taken in a ‘language decision graph.’ If subsections of the graph are defined as being part of a construct, then we can have a lisp style hierarchy of these sequences; so instead of just a program being (1, 1, 7, 3, 5) maybe it’s ((1, 1), 7, (3, 5)). So, macros are functions that operate on the program as represented in this list form, and compilers/interpreters when encountering macro calls evaluate the macro transformation and substitute the results into the code where the original macro call was.

A good candidate for a syntax-free language to try building would be something along the lines of the Domain/Converter system: it has Domains, which involve a set of data structures and operations on them, and it has Converters which map data structures to data structures. You would either be defining a type (e.g. a certain type of data structure), constructing instances of already defined types, specifying sequences of operations on instances, specifying ‘control flow’ of instances (i.e. pushing or  pulling them through Converters into different Domains).

*********OLD NOTES***************

There's a bug when navigating at the line level (maybe word) and moving around on curly braces -- it will jump to the previous method.

-------------------------------------
There seems to be an issue with too much memory consumptions (which really may just be the GC releasing too slowly) when using the 1.7JVM (using around 300megs), whereas on 1.6 mem usage is fine (60megs). This certainly seems to be related to having too many Character arrays (i.e. Strings -- StringBuilders  more accurately I think) due to creating too many GLStrings/GLStringAtoms for displaying code.